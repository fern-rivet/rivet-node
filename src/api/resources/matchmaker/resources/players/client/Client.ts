/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import { Rivet } from "@rivet-gg/api";
import urlJoin from "url-join";
import * as serializers from "../../../../../../serialization";
import * as errors from "../../../../../../errors";

export declare namespace Client {
    interface Options {
        environment?: environments.RivetEnvironment | environments.RivetEnvironmentUrls;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Validates the player token is valid and has not already been consumed then
     * marks the player as connected.
     * # Player Tokens and Reserved Slots
     * Player tokens reserve a spot in the lobby until they expire. This allows for
     * precise matchmaking up to exactly the lobby's player limit, which is
     * important for games with small lobbies and a high influx of players.
     * By calling this endpoint with the player token, the player's spot is marked
     * as connected and will not expire. If this endpoint is never called, the
     * player's token will expire and this spot will be filled by another player.
     * # Anti-Botting
     * Player tokens are only issued by caling `lobbies.join`, calling `lobbies.find`, or
     * from the `GlobalEventMatchmakerLobbyJoin` event.
     * These endpoints have anti-botting measures (i.e. enforcing max player
     * limits, captchas, and detecting bots), so valid player tokens provide some
     * confidence that the player is not a bot.
     * Therefore, it's important to make sure the token is valid by waiting for
     * this endpoint to return OK before allowing the connected socket to do
     * anything else. If this endpoint returns an error, the socket should be
     * disconnected immediately.
     * # How to Transmit the Player Token
     * The client is responsible for acquiring the player token by caling
     * `lobbies.join`, calling `lobbies.find`, or from the `GlobalEventMatchmakerLobbyJoin`
     * event.  Beyond that, it's up to the developer how the player token is
     * transmitted to the lobby.
     * If using WebSockets, the player token can be transmitted as a query
     * parameter.
     * Otherwise, the player token will likely be automatically sent by the client
     * once the socket opens. As mentioned above, nothing else should happen until
     * the player token is validated.
     *
     */
    public async connected(request: Rivet.matchmaker.PlayerConnectedInput): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.RivetEnvironment.Production).matchmaker,
                "/players/connected"
            ),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.matchmaker.PlayerConnectedInput.jsonOrThrow(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.RivetError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.RivetError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.RivetTimeoutError();
            case "unknown":
                throw new errors.RivetError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Marks a player as disconnected. # Ghost Players If players are not marked as disconnected, lobbies will result with "ghost players" that the matchmaker thinks exist but are no longer connected to the lobby.
     */
    public async disconnected(request: Rivet.matchmaker.PlayerDisconnectedInput): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(
                (this.options.environment ?? environments.RivetEnvironment.Production).matchmaker,
                "/players/disconnected"
            ),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.matchmaker.PlayerDisconnectedInput.jsonOrThrow(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.RivetError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.RivetError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.RivetTimeoutError();
            case "unknown":
                throw new errors.RivetError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
